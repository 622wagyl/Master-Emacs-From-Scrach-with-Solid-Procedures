#+TITLE: Master Emacs
* 00.Preface

步步为营一步一个脚印, "零秒"乃调用直觉力, 非物理概念上的“零秒”；

一个以讹传讹的观念"Emacs很难且耗费时间", 标题"零秒"有意打消对Emacs学习的成见. 通过点出Emacs中的关键点的方式, 心有灵犀一点通, 举一反三, 一通百通. 而不必案牍劳形, 悬梁刺股.
曾国藩的战术“结硬寨, 打呆仗”, 初时很慢, 待工事渐成, 则坚不可摧；
同时努力学习SICP的策略, 首先抛出点滴星火，再看时，已成燎原之势。
以直觉力为基础，步步为营，稳扎稳打，构筑Emacs技能。


是为序.

Emacs的简单, 则一言以蔽之, 只是一个Meta键.
Meta键(键盘上的option/alter键)
Meta的词源含义是higher, beyond,没有最高,只有更高.
中文译为"元", 发端处, 源头处;
So Meta is Source, and it relates to source code.
Meta关联Source-Code, 在Source-Code中, Function又是的一等公民.
Emacs的简单策略便是将Meta键i绑定到Function上..
M-x (x for execucte), 在此之后, 便可以天马行空的查询要做的事情,
比如插入当前的日期:

至此, Emacs从战略层面上的所有事情便结束了, 剩下的事情仅仅是战术层面上的高效问题与缝缝补补的实现.

*Emacs的第一个策略: 引入Ctrl键*

比如从目录中打开一个文件, 可以M-x find-file,
需要键入十一个字符 Ctrl策略, 可以C-x C-f. 只需要键入4个字符.
sequnces调用functions的过程, 称之为Command. Command=Contrl, 由此也能反过来看到选择Ctrl键也是语义绑定.

* 01.Semantic Keybinding

Emacs从最源头处, 用Meta-Execte调用所有的function; 然后通过定义Ctrl的技术, 简化Meta的流程.

正文从语义化快捷键入手, 辅助在5分钟之内永久记忆(Never have a second look), 20多个一级快捷键(高频), 30几个二级绑定键(中频), 闲看三级快捷键(低频); 以及按照功能, 按照目的, 按照插件分类的表格.
答题区上表格和秒记方法.


C-x, C-h的区别, 一级绑定, 将C-x中的x去掉, 只剩下
从character讲起, meta的词源是higher,


与vim的关键区别是绑定的键是有具体含义,可逻辑, 可推导.

 character, word, line, sentence, page, article.

一级绑定之cursor光标的移动: (高频)
在一级绑定中, C-x, M-x中的x(execute)省略, 简化为C-与M-x;
光标操作的对象:
character, word, line, sentence, (*paragragh),
page, buffer.

1. Character and Word
C-f (M-x forward-char) 向前移动一个字符的位置
C-b (M-x backword-char) 向后移动一个字符的位置
char是最小的操作单元, char之上则是word, 回顾上文阐述的meta的词源含义是higher,因此Meta绑定相同的键, 范围要比Ctrl更大一点, 由此, 比char大一级的是word
M-f (M-x forward-word) 向前移动一个单词的位置.
M-b (M-x backword-word) 向后移动一个单词的位置.

2. line and sentence.
C-e (e for end) move to end of line,
C-a (a for ahead) move to ahead of line
同样的逻辑,Meta比Ctrl的范围高一个等级
M-a move to ahead of the sentence
M-e move to end of the sentence.

以上两点为光标在水平方向的移动(horizontal), 与之相对应的纵向(Vertiallly)移动的操作.

3. Vertical Movement between lines
C-n (调用function next-line), 向下移动一行
C-p (previous-line)
接下来, 有意思的事情来了.
由character和line操作可知, 绑定相同的键, Meta的作用范围总是比Ctrl更高一级, 但是此时查看:
M-p
M-n
发现Emacs没有定义这两个key-sequnces, 根据前面的逻辑, M-p应该向上移动更多行, 至少比一行要多; Emacs竟然没有定义, 这真是千载难逢的良机.
暂时按下不表, 先小结Ctrl的光标操作. Ctrl能操作的最大单位是line, 更大范围的光标动作交由Meta完成.

4. Vertically Page Down and Up
向上翻页M-v, v当然是vertical, 而Meta是higher, 往更高处纵向移动, 当然便是UP,
那么向下呢? 既然Meta相对于Ctrl而higher, 反过来Ctrl则是Lower;
因此向下翻页是C-v.
此处的心思, 一级绑定, 始终用最少的动作, 最少的触发键, 如果绑定三个键, 则不需要Ctrl的参与.
M-v-u(up), M-v-d(down)向下.
M-v与C-v辅助便利地向上和向下翻页, 问题是他们是整屏, 整屏地翻页, 大多数时候, 这不是我们想要的. 我要半屏半屏的翻页.

现在重新回到M-p与M-n, 绑定半屏翻页.

#+begin_src emacs-lisp :session sicp :lexical t
(defun scroll-half-page-down ()
  "scroll down half the page"
  (interactive)
  (scroll-down (/ (window-body-height) 2)))

(defun scroll-half-page-up ()
  "scroll up half the page"
  (interactive)
  (scroll-up (/ (window-body-height) 2)))

(global-set-key "\M-n" 'scroll-half-page-up)
(global-set-key "\M-p" 'scroll-half-page-down)
#+end_src

#+BEGIN_QUOTE 备注
因为设置了触控板(或者鼠标)Invert scroll direction(Natural Scrolling), 因此up与down是反着映射到next和previous的
#+END_QUOTE

5.Buffer
M-<, to the biginning of the buffer
M->, to the end of the buffer.
# 只要记着ctrl只管到line, 其余全部都是Higher的Meta的工作.
* 02.Emacs as an Editor
[[01.semantic keybinding]] 初窥了Emacs简单易用的特性之一便是语义化键绑定,
语义化包含两个方面:
1) Character keys的语义化, 这一点明了易懂, n for next, p for previous; 而非j for next, k for previous.
2) Control keys的语义化, 求根问底Meta的词源, 病以meta的higher(beyond)基石; 不仅可以不费力的记住Cursor操作, 依照同样的逻辑, 可以拆解全部的内置快捷键.

移动Cursor的目的, 一则为浏览阅读, 二则为编辑做准备, 是编辑的前驱步骤.
当聊起编辑器时候, 一个著名的段子"Emacs不是好的编辑器, 而是一个操作系统"; 如果追问一句"请问, 您对编辑器定义是什么?", 立刻会发现所谓编辑器圣战, 便是茶余饭后的小品或者群口相声, 以"段子", 调剂案牍劳累.

"When I see a bird that walks like a duck and swims like a duck and quacks like a duck, I call that bird a duck.", 编辑器的基本功能曲指可数.

编辑器的基本功能:
以行为单位,
复制, 黏贴, 增删改查, 其中查是关键, 应该放在前面
对文本的初始是最关键的一点, Linux基于流管理.

+ 最基本
  - 复制黏贴 (M-w, C-y)
+ 增删改查
  - insert (C-q quotation)
  - delete(C M d delele), kill ring
  - modify(undo, transpose, uppercase, lowercase, title,
  - Search(Swiper…)
+ Arguments
  - Numeric arguents C-u
  - Repeat C-x z

+ Completion(yasnippet)
  - indentation (M-i 缓解小指的负担
  - white space(C-x C-o)
  - Filling(global-visual-line-mode)
  - Spelling-checking
+ Special
  - Register

详细叙述delte
键的绑定同样遵循语义化的原则, 比如Delete(killing)
<delete>键(即backspace退格键, backword);
与C-<del> 搭配是删除一个字符,
与M-<del>则是倒退删除一个单词;
与backwords对应的是forwards,(进格删除)
C-d M-d分别进格删除一个字符和一个单词.

Killing的范围比delete大;
C-k是删除到行尾, M-k是删除到句尾, 跟前面一致. 以上是forwards进格删除,
对行的backwardst退格删除 C-x <del>

*Topic1*

这么多的键绑定, 从语义化的理解是一方面, 更重要的一方面可能应该去找捷径, 比如调用直觉和由此带来的强烈满足感和成就感.

编辑过程中对blank-lines的处理,

C-x C-o调用(delete-blank-lines)

C-x C-o的绑定键没有逻辑, o是个洞吗? 一个洞代表空行?

Emacs Manual中很多这样的处理细分领域的绑定键, 头悬梁锥刺股的用下来, 对emacs的热情和兴趣早早磨光了.

回到C-x C-o调用(delete-blank-lines)

假设有这样四行

#+BEGIN_QUOTE
"The quick brown fox jumps over the lazy dog"


"The quick brown fox jumps over the lazy dog"
#+END_QUOTE

当前的光标在第一行上的fox,后 发现两行文字中间的空行是多余的, 因此要删掉.

需要动用人肉劳力这样做:

    C-n 管标移动到下一行
    连续两次C-k删除空行
    然后凭借超强的记忆力(记住刚才是在fox的位置, 和导弹一般精确的点位控制回到fox后面.

劳神费力.

应用C-x C-o呢? 可以在第一行的任意位置上调用C-x C-o, 下面的空行会自动删除.

怎样从直觉上理解呢?

    光标在第一行的某个点上, 然后调用一个命令, 在光标之外的另外一个地方会立刻发生某件事情, 这就是远程控制呗;
    更直觉一点, 这边是"意念移物"呗,

由此从直觉里生发的成就感和兴趣会驱动我们应用更加复杂的命令和组合.

P.S. 作为对"零秒" 这个标题党的补充.


*Topic2 对比Search功能的Emacs操作与命令行操作*
Emacs的优势是对数据和查询结果的便捷二次处理.
比如想从宏观上了解下Emacs手册中中全部whitespace操作.
[[file:images/2.目录界面.png]]

可以从Terminal中完成
#+BEGIN_SRC bash
find . -type f -exec grep --color -inH --null -e  "whitespace" \{\} +
#+END_SRC
[[file:images/2.terminal界面.png]]

虽然可以看到结果, 但没法做简单的统计.
即使加上nl
#+BEGIN_SRC bash
find . -type f -exec grep --color -inH --null -e  "whitespace" \{\} + | nl
#+END_SRC
[[file:images/terminal界面2.png]]

也只能大略了解到’whitespace’在整个文档中, 有95句话提到过.

而在Emacs中执行同样的命令:
C-x grep-find;

则瞬间眼明心亮, 有95句话有一个或多个whitespace这个单词, 总计有151个. 而且在 Killing.org 这个文件中有6句话, 在 text.org 中有5句, 在 Display,org 中有17句话, 在 Program.org 中也有17句, 等等,

[[file:images/emacs界面.png]]

Emacs中执行命令的突出优势是简单方便的二次处理.

*小结*

目前的流程图 Meta --> Control ---> Cursor ---> Edit
由Meta的词源语义出发分析Emacs的快捷键绑定, 引入Ctrl键简化输入过程, 光标的移动作为edit的前置步骤, 以find-grep查询收尾基本的编辑功能.
在切入到God's Eyes(Dired) and God's Hands(Booksmarks)之前,
光速浏览File的基本操作(读取和保存)
C-x C-f (M-x find-file) 找到并打开文件
C-x C-r (r是read-only), 比如浏览自己的配置文件, 要避免无心修改掉东西.
C-x C-s (s,save) 保存单个文件
C-x s   保存全部文件, 保存全部文件功能更常用, 因此组合键也少.
最后在个人配置上添加两行, 设置自动保存文件.

#+begin_src emacs-lisp :session mm :lexical t
(setq auto-save-visited-mode t)
(auto-save-visited-mode +1)
#+end_src
以上完结, 马上进入精彩的部分.
* 03.God's Eyes and Hands by Dired and Bookmarks
** Dired初窥
在EmacsManual目录下调出Dird后,
快速略扫各个文件的主要内容.
从配置中添加下面的代码
#+begin_src emacs-lisp :session ss :lexical t
(define-minor-mode dired-follow-mode "Diplay file at point in dired after a move."
  :lighter " dired-f"
  :global t
  (if dired-follow-mode (advice-add 'dired-next-line
                                    :after (lambda (arg)
                                             (dired-display-file)))
    (advice-remove 'dired-next-line (lambda (arg)
                                      (dired-display-file)))))
#+end_src
M-x 调用 =dired-follow-mode=
x
在目录上C-n和C-p上下移动光标.

#+ATTR_HTML: :width 500px
[[file:images/pre-dired.gif]]

** Dired操作归纳:

1. Entering Dired: C-x d
2. Navigation: C-n C-p
3. Delete files: d, x, D
4. Flagging many files at once:
   1) # (file start with #)
   2) ~ (flag all backup files whose name end with ~)
   3) % d regexp (delete all match regex)

5. Visiting Files
   - f or e (visit current file)
   - o (another window to display and switch fucus)
   - C-o (visit but not switch focus)
   - v (view-mode)
   - ^ (dired-up)

6. Dired Marks vs. Flags
   - * * excutable files
   - * m mark
   - * @ symbolic link
   - * / directory
   - * u remove the current
   - U remove all
   - % m regex
7. Operatons on files
   - C copy
   - D delete
   - R rename
   - H hardlink
   - S symblic link
   - Z, c
8. Shell Commands in Dired
   - 这次阅读最大的收获, 可以直接 & 和 X
9. Transform files names
   - % u Uppper-case
   - % l lowercase
10. File comparision
   - dired-diff
11. Subdirectory in Dired
   - i
12. Subdirectories switch in Dired
   -
13. Moving Over Subdirectories
    -
14. Hiding Subdirectories
    -
15. Updating the Dired Buffer
    g
16. Dired and find
   find-name-dired
17. Editing the dired Buffer
    wdired
18. View Images thumbnails
    image-dired-display-thumb

** Register操作归纳

M-x view-register r
# 以下所有的命令最后一个letter, 可以自定义为a-z等任何字母.
1. Saving Positions in Registers
   C-x r r (register r)
   # 可以自定义为 C-x r a (能记住便好)
   C-x r j r (register jump to r)
2. Saving Text in Registers
   C-x r s t (register save to r) "text"
   # 修改为C-x r s t (t for text)
   C-x r i t (regiester insert to r) "text"
   M-x append-to-register t
   M-x prepend-to-register t
3. Saving Rectangles in Registers
   C-x r r e (rectangle region to e);
   # 此处省略一个r, 完整语义(C-x r r r e)
   register rectangle region to r
   C-x r i r (rectangle insert to r )
4. Saving Window Configurations in Registers
   C-x r w w (register window to r)
   # 很好用的命令, 可以早上8点保存一个布局,晚上再看看, 临时记住的布局用winner-mode
   C-x r f f (register frameset to f)
   C-x r j f (jump)
5. Keeping Numbers in Registers
   No practical value.
6. Keeping File Names in Registers
   (set-register r '(file . name))
   (set-register ?z '(file . "/gd/gnu/emacs/19.0/src/ChangeLog")
   # prelude for bookmarks
7. Keyboard Macro Registers
   --
8. Bookmarks
   C-x r m (register bookmark for the current file)
   C-x r m  a-name
   C-x r M (not overwrite)
   C-x r b bookmark (jump or write)
   C-x r l (list all bookmarks)
   M-x bookmark-save
   M-x bookmark-load filename
   M-x bookmark-write filename
   M-x bookmark-delete bookmark
   M-x bookmark-insert-location bookmark
* 04.Emacs as a Notebook by Org
** Org Notebook操作总结:
*** Document Structure
- Headlines
  A cleaner outline view
- Visibility Cycling
  S-TAB =org-global-cycle=
  C-u C-u TAB (=org-set-startup-visibility=)
  C-u C-u C-u TAB (=outline-show-all=)
  # 替代反复设置fundermantal-mode的用法.
  C-c C-k (=outline-show-branches=)
  # 新学到一个方便的操作
　C-c C-x b (=org-tree-to-indirect-buffer=)
  # 不如直接使用narrow
- Initial visibility
#+BEGIN_EXAMPLE
    #+STARTUP: overview
    #+STARTUP: content
    #+STARTUP: showall
    #+STARTUP: showeverything
#+END_EXAMPLE
- Motion
  (略)
- Structure Editing
  M-LEFT =org-do-promote=
  M-RIGHT =org-do-demote=
  M-S-LEFT =org-demote-subtree=
  M-s-RIGHT =org-promote-subtree=
- Sparse Tree
  C-c / r
  查询使用swiper
- Plain List
  kbd(M-RET) (=org-insert-heading=)
  kbd(M-S-RET) (=org-insert-checkbox=)

  C-c ^ 排序
- Drawers
  a =PROPERTIES= drawer
- Blocks:
  =#+BEGIN= ... =#+END=
** Tables
** Hyperlinks
  






* 04-Case:如何"严肃"阅读一本书
** 序
本文为项目"步步为营, 零秒精通Emacs"的第四章"Emacs as a Notebook by Org"

一本书读过之后, 当再次拿起来的时候, 仿佛读新书一样;
读了, 看了, "劳民伤财"投入大量时间与精力, 但是记不住怎么办?
本文试图解决这个问题,
以SICP的第四章(Metalinguistic Abstraction)为例

论述分为六个部分:
1. 启动-绘制大纲, 拿着地图阅读;
2. 过程控制, 利用org-clock以及标签, 在控制过程的同时, 为后续的复盘预备第一手的线索;
3. 阅读管理, 正文阅读阐述如何应用标签提高阅读效率, 并为后续查询参阅提供好用的数据结构;
4. 案例与习题, 讨论怎样索引和处理书中的案例与习题;
5. Org的撒手锏;
6. 收尾, 总结探讨提高技术水平的同时, 稳扎稳打从每次阅读中提升英语能力.
附录: 参看书目

** 启动-绘制大纲

关于大纲目录的重要性, 引用王垠在"如何成为一个天才"中的一段话:
#+BEGIN_QUOTE
如果你看过John Nash 的传记《A Beautiful Mind》，就会发现他与其他人的不同.Nash看书只看封面和开头，把这书要讲的问题了解清楚之后，就自己动手解决. 最后，他完全依靠自己的“头脑暴力”创造出整本书的内容.
#+END_QUOTE
天才的能力或许难以企及, 天才的方法却可学可至.
一本书拿过来, 先看封面和目录, 纸笔绘制出来;
目录便是大纲结构, 投入10~30分钟的时间在大纲结构上, "头脑风暴"如果你在写这本书, 将会如何展开, 根据你的经验与想象, "编造"出来大致脉络, "编造", 无拘无束的"编造".
益处有四:
1. 梳理和回顾你的经验和知识结构;
2. 编造的过程会滋生阅读的欲望, 因为某些部分造不出来;
3. 当拿着"我"的思想与"作者"的思想对照之时, 阅读的过程已变为求证的过程;
4. 两个思想互相碰撞, 有共鸣有拍案, 不仅会事半功倍的提高阅读效率; 还能更深入的掌握书中的精妙之处.
退一步, 如果一点想法都没有, 半句话也编不出来, 那最好将背诵下来, 待到"厕上枕上马上", 从脑子里拿出来慢慢反刍咀嚼, 驱动潜意识这种神奇的力量开始工作.

纸笔绘制的方法有助于记忆, 而且可以放在手边作为地图参阅.

*** 用emacs-org参阅大纲结构:
**** 方法一: C-n S(shift)-tab
控制目录显示的深度,比如C-2 S-tab显示到2级目录,
#+ATTR_HTML: :width 300px
[[file:images/启动-显示到二级目录.png]]
方法的优点是可以自定义控制目录显示的深度

**** 方法二:
直接应用S-tab或者C-u Tab轮巡
  ,-> OVERVIEW -> CONTENTS -> SHOW ALL --.
  '--------------------------------------'
重复操作一次则显示在不同的结构

**** 方法三:
TOC结构, 安装doom-emacs后, 在任意位置, 应用:toc:便能自动生成目录
#+ATTR_HTML: :width 300px
[[file:images/启动-toc-2.png]]

**** 方法四
推荐的方案,纸笔绘制, 放在手边参阅.
[[file:images/sicp-04.metalinguistic.jpeg]]
** 过程控制
*** Clock-in and Clocxk-out
当前章节下调用  =M-x org-clock-in=,
- 一方面可以计时,
- 再者则随时提醒当前所处的位置和任务, 及时跳转到其他的buffer中, 也会看到, 比如从4.4.1 Deductive Information Retrieval中激发了clock-in, 则即使在这篇文章的编辑页面, 依然能看到当下的任务, 随时提醒你回去执行.
#+ATTR_HTML: :width 500px
[[file:images/过程-clock-in.png]]
- clock-in置顶当前任务, 为后文"阅读管理"添加标签提供便利.

*** 随手建立todo任务
比如阅读过程中,发现svg的图片格式在black模式下, 认读需要眼睛对到屏幕上仔细得瞧个清楚, 因此设置任务将inline的图片逐步去掉, 修改成文本格式.
#+ATTR_HTML: :width 500px
[[file:images/过程-设置todo.png]]
任务完成后变更todo为done

*** 提出问题?
过程控制中最重要的一点, 初次阅读的时候, 有困惑的地方, 不理解的地方, 尤其是与你在第一步"编造"和"想象"的内容不一致的地方, 标注成"问题?", 因为是自己的笔记, 只要稍微有一丝疑问, 马上标出来, 我觉着这是宝贵的财富.
一方面, 如果不标注, 过5分钟, 会忘记刚才在想什么
另一方面, 当一年后在读这本书的时候, 可以了解当时的水平, 当时的思考脉络.
问题统一设置成 =问题?= 的格式, 如此, 不仅是在正文的行首, 或者和在代码的内部, 都能方便查到; 又不会多余查到正常使用的"问题"这个词汇.
#+ATTR_HTML: :width 500px
[[file:images/过程-问题.png]]
问题解决后, 在后面标注v,v当做是对号.
[[file:images/过程-问题v.png]]
如图, 刚才的12个问题解决了7个, 剩下的可能需要发到stackoverflow上.

*** 小结：
过程控制使用了todo, 问题标签．
后文的＂阅读管理＂中探讨, 使用filter知识点的标签 #得到-概念 #得到-语法 #得到-行文(学习到了文章的结构) #得到-关联(关联到过往的经验) #得到-应用(对后续对概念对知识点应用的思); #短评(没有想好归类的,使用短评) #洞见 #洞见-关联 #洞见-应用 #拍案 #词汇 #总结
等等,
使用"问题?"等标签的优点:
一是: 为后续查询提供结构化的关键词
二是: 可扩展性, 一本书, 二读, 三读, 四读, 可以在既有的标签规则下, 添加新的想法.

** 阅读管理
金圣叹点评"水浒传", 也是为他深入理解文章,
阅读过程中, 给评注设置标签有三个作用:
1. 分类记录, 不然写得评注很多, 复盘回顾则眉毛胡子一把抓
2. 从自己的角度, 将文章重新格式化, 正文的目录是作者的结构, 标签可以按照自己的想法构建.
3. 为二读, 三读提供结构化的线索.

*** 短评
短评是不分类的标签, 可以意识流, 读到哪里, 有想法立刻写下来.
无拘无束, 不给大脑是否要分类, 分类到哪里的负担.
待到二读, 三读的时候再适当"短评"的内容归类, "短评"为后面的动作提供原材料.
#+ATTR_HTML: :width 300px
[[file:images/阅读-短评.png]]

*** 洞见
读着读着, 对作者的阐述生发共鸣, 或者比"绘制大纲"阶段中"编造"的内容阐述的精彩, 又或者在胸中困顿许久没想明白的点, 在此处豁然开朗.
#+ATTR_HTML: :width 300px
[[file:images/阅读-洞见.png]]
举例比如 assignment and definition这一段, 从evaluator的角度, 赋值(assignment)与定义(definition)的本质是一样的, 都是set!, 这也完全符合直觉.
此处标注为洞见, 是因为刚从python入门编程的时候, 学习赋值与函数定义.
#+begin_src ipython :session SICP :results output
a = 9
def foo(x): return x * x
#+end_src
很容易直觉到或者看到这里的"def"与"="是一样的, 都是给一个变量赋值.
刚学python的时候, 将这个想法分享到微信群组, 招惹来汹涌的嘲笑, 各种跳大神纷纷登场.
上面的这一段, 也写进去, 标签是 =#洞见-关联= 关联到既往的经验中.
与 =洞见-关联= 标签相对应的是 =洞见-应用=, 既然有了这个洞见, 日后怎样应用?

*** 拍案
"拍案"是"洞见"的升级, 给感情发挥的空间, 没有规则, 就是突然醍醐灌顶,拍案叫绝.
#+ATTR_HTML: :width 300px
[[file:images/阅读-洞见.png]]

比如这一章的开头, 作者引述的一段话
#+BEGIN_QUOTE
  ... It's in words that the magic is---Abracadabra, Open Sesame, and the rest---but the magic words in one story aren't magical in the next. The real magic is to understand which words work, and when, and for what; the trick is to learn the trick.
# 拍案-起讲, 总是如此直白的掰开道理, 知微见著.
#+END_QUOTE

起讲"metalinguistic"之前, 作者引述这样浅显直白又颇具启发的用例.
当然与"洞见"一样, 后面在阅读的时候也加上"拍案-关联", "拍案-应用"标签,

小结:
从短评, 洞见, 到拍案, 都是自己的思路, 后面的"得到"标签标注知识点.

*** 得到
采用"得到"标签, 是因为比"知识点"少一个字.
**** 得到-概念:
标注文中新阐述的概念.
#+ATTR_HTML: :width 300px
[[file:images/阅读-得到-概念.png]]

比如文中的一个角度对CS的定义
#+BEGIN_QUOTE
 Seen from this perspective, the technology for coping with large-scale computer systems merges with the technology for building new computer languages, and computer science itself becomes no more (and no less) than the discipline of constructing appropriate descriptive languages.
#+END_QUOTE
**** 得到-语法：
标注语言的语法
#+ATTR_HTML: :width 300px
[[file:images/阅读-得到-语法.png]]
上图标注if-predicate, 是因为我的潜意识里, if总是两个predicates.

**** 得到-八股
从文章中学习到的行文技巧, 起承转合, 类比比喻等等.
而八股文有着严谨的起承转合的结构.
#+ATTR_HTML: :width 300px
[[file:images/阅读-得到-八股.png]]

再看第三章的第一段,承接前两章然后引出下文.
#+ATTR_HTML: :width 300px
[[file:images/阅读-得到-八股2.png]]

**** 得到:
新的知识点, 没想好归类, 直接用得到.
以上, 搜"# 得到"的时候, 可以

*** 总结标签:
此处略过, 最好每一节都有一个总结.

*** 词汇:
此处承接"尾声"部分, 积累词汇与表达, "积土成山, 风雨兴焉"
利用org的规则, 词汇标注有两种方式.
其一:
#+ATTR_HTML: :width 300px
[[file:images/阅读-词汇.png]]
比如本章节中的两个单词, evaluate与apply.
eval便是输入expression, 输出value;
拆解evaluate这个单词,
evaluate = ex(out) + value
将value拿出来就是evaluate, 与eval的过程百分百匹配; 直觉可以从这样的"跬步"中慢慢建立起来.
apply就献丑了.
其二:
应用 ~vacabulary~ 标注单词
#+ATTR_HTML: :width 300px
[[file:images/阅读-词汇2.png]]
标注了14个词汇.


*** 阅读管理小结:
1. 短评, 基础的原材料标签, 有启发有想法随时记下来, 作为后续分类的基础;
2. 洞见, 有共鸣, 有豁然开朗的地方
3. 拍案, 醍醐灌顶, 就像高呼几声的地方
4. 得到, 知识点
5. 总结
6. 词汇,
7. 关联与应用放到相应的标签后面.
** 案例与习题
** 收尾
* 05.Emacs as a Agenda by Org
* 06.Org your life all-in-one as  book manager, database manager, memory manager etc
* 07.Programming
* 08.Assistance to Programming
* 09.Literate Programming

* Appendix A: Learn by raise quesiton and harvest answer.
* Appendix B: Git Version Control

|-----------------------+------------------------------+----------------------------------------------|
| Objects               | Features                     | Actions:                                     |
|-----------------------+------------------------------+----------------------------------------------|
| 0.Introduction        |                              |                                              |
|                       | Faster commands              |                                              |
|                       | Stability                    |                                              |
|                       | Isolated Environments        |                                              |
|                       | Efficient Merging            |                                              |
|-----------------------+------------------------------+----------------------------------------------|
| 1.Overview            | Objects:                     | Actions:                                     |
|                       | 1.working directory          | configure                                    |
|                       | 2.staging area               | recording                                    |
|                       | 3.Commit history             | undoing                                      |
|                       | 4.developmnent branches      | branch (non-linear)                          |
|                       | 5.remotes                    | remote                                       |
|-----------------------+------------------------------+----------------------------------------------|
| 2.Configuration       | 1) User Info:                |                                              |
|                       |                              | git config --global user.name                | 
|                       |                              | git config --global user.email               |
|                       | 2) Editor:                   |                                              |
|                       |                              | git config --global core.editor emacs        |
|                       | 3) Alias:                    |                                              |
|                       |                              | git config --global alias.ci commit          |
|                       | .inspect                     |                                              |
|                       |                              | git config -l                                |
|-----------------------+------------------------------+----------------------------------------------|
|                       | help:                        | git help log                                 |
|                       |                              | man git-log                                  |
|                       |                              | tldr git-log                                 |
|-----------------------+------------------------------+----------------------------------------------|
| 3.Recoding Chaneges   |                              |                                              |
|                       | Staging area:                |                                              |
|                       |                              | git add                                      |
|                       |                              | git rm --cached                              |
|                       | .inspecting:                 |                                              |
|                       |                              | git status                                   |
|                       |                              | git diff (--cached)                          |
|-----------------------+------------------------------+----------------------------------------------|
|                       | Commits                      |                                              |
|                       |                              | git commit                                   |
|                       | .inspecting                  |                                              |
|                       |                              | git log                                      |
|                       |                              | git log --oneline  <file>                    |
|                       |                              | git log <since> ... <until>                  |
|                       | Tagging commit               |                                              |
|                       |                              | git tag -a v1.0  'stable version'            |
|-----------------------+------------------------------+----------------------------------------------|
| 4.Undoing Changes     | 1) Woriking directory        |                                              |
|                       |                              |                                              |
|                       |                              | git reset --hard HEAD                        |
|                       |                              | git clean -f (git rid of unstaged files)     |
|                       | .individual file:            |                                              |
|                       |                              | git checkout HEAD <file> (most frequent)     |
|-----------------------+------------------------------+----------------------------------------------|b
|                       | 2) Staging area              |                                              |
|                       |                              | git reset HEAD <file> (extra staged file)    |
|                       |                              | (No --hard here)                             |
|-----------------------+------------------------------+----------------------------------------------|
|                       | 3) Commits                   |                                              |
|                       | .resetting                   |                                              |
|                       |                              | git reset HEAD~1                             |
|                       | .reverting                   |                                              |
|                       |                              | git revert <commit-id> (created new commit ) |
|                       | .ameding                     |                                              |
|                       |                              | git commit --amend                           |
|-----------------------+------------------------------+----------------------------------------------|
| 5.Branches            | 1) Manipulate brnaches       |                                              |
|                       | .listing branches            |                                              |
|                       |                              | git branch                                   |
|                       | .creating branches           |                                              |
|                       |                              | git branch <name>                            |
|                       |                              | git checkout -b <name>                       |
|                       |                              | .git/refs/heads/develop                      |
|                       | .deleting branches           |                                              |
|                       |                              | git branch -d, -D                            |
|                       |                              |                                              |
|                       | Checking out branches        |                                              |
|                       |                              | git checkout  <branch>                       |
|                       | .detached                    |                                              |
|                       |                              | git checkout -b <new-branch-name>            |
|-----------------------+------------------------------+----------------------------------------------|
|                       | 2) Merging branches          |                                              |
|                       | .fast-forward:               |                                              |
|                       |                              | git checkout master                          |
|                       |                              | git merge some-feature                       |
|                       | .3-way merge:                |                                              |
|                       |                              | same as the above                            |
|                       | .merge conflicts             |                                              |
|                       |                              | <<<<<<HEAD                                   |
|                       |                              | ==================                           |
|                       |                              | >>>>> some-feature                           |
|-----------------------+------------------------------+----------------------------------------------|
|                       | 3) Branches workflow         |                                              |
|                       | .types of branches           |                                              |
|                       |                              | permanent or topic                           |
|                       | .permanent_branch            |                                              |
|                       |                              | master(public ), develop,                    |
|                       | .topic_branch                |                                              |
|                       |                              | feature and hotfix                           |
|-----------------------+------------------------------+----------------------------------------------|
|                       | 4) Rebasing:                 |                                              |
|                       |                              | git checkout some-feature                    |
|                       |                              | git rebase master                            |
|-----------------------+------------------------------+----------------------------------------------|
|                       | .interactive_rebasing:       |                                              |
|                       |                              | git rebase -i master                         |
|                       |                              | (Notice for rewriting)                       |
|-----------------------+------------------------------+----------------------------------------------|
| 6.Remote Repositories |                              |                                              |
|                       | 1) Manipulate remotes:       |                                              |
|                       | .listing remotes:            |                                              |
|                       |                              | git remote                                   |
|                       |                              | git remote -v                                |
|                       | .creating_remotes:           |                                              |
|                       |                              | git remote add <name> <path-to-repo.         |
|                       | .deleting_remotes:           |                                              |
|                       |                              | git remote rm <remote-name>                  |
|-----------------------+------------------------------+----------------------------------------------|
|                       | 2) Remote branches:          |                                              |
|                       | .fetching_remote_branches    |                                              |
|                       |                              | git fetch <remote> <branch>                  |
|                       |                              | git branch -r                                |
|                       | .inspecting_remote_branches: |                                              |
|                       |                              | git log origin/master                        |
|                       | .merging/rebsing:            |                                              |
|                       |                              | git checkout some-feature                    |
|                       |                              | git fetch origin                             |
|                       |                              | git merge origin/master                      |
|                       |                              | (littered with meaninglesss merge commits)   |
|                       |                              |                                              |
|                       |                              | git checkout some-feature                    |
|                       |                              | git fetch origin                             |
|                       |                              | git rebase origin/master                     |
|                       | .pulling:                    |                                              |
|                       |                              | git pull origin/master (--rebase )           |
|                       | .pushing:                    |                                              |
|                       |                              | git push <remote> <branch>                   |
|                       |                              |                                              |
|-----------------------+------------------------------+----------------------------------------------|
|                       | 3) Remote workflow:          |                                              |
|                       | .bare_repository:            |                                              |
|                       |                              | git init --bare <path>                       |
|                       | .centralized_workflow:       |                                              |
|                       |                              | git fetch origin master                      |
|                       |                              | git rebase origin/master                     |
|                       |                              | git push                                     |
|                       | .integrator_workflow:        |                                              |
|                       |                              | github的模式                                 |
|-----------------------+------------------------------+----------------------------------------------|
| Conclusion            |                              |                                              |
|                       | 1.working directory          |                                              |
|                       | 2.staging area               |                                              |
|                       | 3.commit history             |                                              |
|                       | 4.branches                   |                                              |
|                       | 5.remotes                    |                                              |
|-----------------------+------------------------------+----------------------------------------------|

- detached
Note: checking out '1a'.

You are in 'detached HEAD' state. You can look around, make experimental
changes and commit them, and you can discard any commits you make in this
state without impacting any branches by performing another checkout.

If you want to create a new branch to retain commits you create, you may
do so (now or later) by using -b with the checkout command again. Example:

  git checkout -b <new-branch-name>

HEAD is now at 613ae49 Chapter 1: initial version (1a)

<<<<<<< HEAD
=======

* Appendix C: Install Extensions
** Plantuml
*** 安装
- [[https://github.com/skuro/plantuml-mode][plantUML-mode-in-github]]
#+BEGIN_SRC bash
sudo apt install plantuml
M-x package-install<RET>
plantuml-mode<RET>
#+END_SRC
或者从 =.doom.d/init.el= 中去掉 =plantuml= 的Comments
*** 配置
- [[https://plantuml.com/download][plantuml-download]]
下载"plantuml.jar"到相应文件夹.
#+begin_src emacs-lisp :session sicp :lexical t
;;PlantUML
(setq org-plantuml-jar-path "~/.doom.d/extensions/plantuml.jar")
(setq plantuml-jar-path "~/.doom.d/extensions/plantuml.jar")
(setq plantuml-default-exec-mode 'jar)
#+end_src

#+RESULTS:
: jar

Note: 不要使用 =M-x plantuml-download-jar<RET>=
下载的非最新版本.

* Appendix D: Email Management
** Sending Mails From @qq.com
*** 从qq邮箱的设置中开启SMTP等服务

[[file:./images/qq邮箱设置.png]]

*** Config SMTP
从.emacs中添加配置:
#+begin_src emacs-lisp :session sicp :lexical t
(setq message-send-mail-function 'smtpmail-send-it)
(setq user-mail-address "abst.proc.do@qq.com")
(setq user-full-name "abst.proc.do")

(setq smtpmail-smtp-user "abst.proc.do@qq.com"
      smtpmail-smtp-server "smtp.qq.com"
      smtpmail-smtp-service 465
      smtpmail-stream-type 'ssl)

;;Debug
(setq smtpmail-debug-info t)
(setq smtpmail-debug-verb t)
#+end_src

*** Authorization
短信获取qq邮箱的授权码后, 新建文件 =.authinfo=
#+begin_src emacs-lisp :session email :lexical t
machine smtp.qq.com  login abst.proc.do@qq.com password 授权码(比如abcd等)
#+end_src
配置文件中添加
#+begin_src emacs-lisp :session email :lexical t
(require 'auth-source);; probably not necessary
(setq auth-sources '("~/.authinfo" "~/.authinfo.gpg"))
;;(customize-variable 'auth-sources) ;; optional, do it once
#+end_src

*** Testing
此时完整的配置文件为:
#+begin_src emacs-lisp :session email :lexical t
;;Sending Email

(require 'auth-source);; probably not necessary
(setq auth-sources '("~/.authinfo" "~/.authinfo.gpg"))
;;(customize-variable 'auth-sources) ;; optional, do it once

(setq message-send-mail-function 'smtpmail-send-it)
(setq user-mail-address "abst.proc.do@qq.com")
(setq user-full-name "abst.proc.do")

(setq smtpmail-smtp-user "abst.proc.do@qq.com"
      smtpmail-smtp-server "smtp.qq.com"
      smtpmail-smtp-service 465
      smtpmail-stream-type 'ssl)

;;Debug
(setq smtpmail-debug-info t)
(setq smtpmail-debug-verb t)
#+end_src

C-x m (Compose-mail)

[[file:./images/sending-email.png]]
C-c C-c (message-send-and-exit)
提示发送成功后, 检查qq邮箱.

[[file:./images/qq-receive-mail.png]]

上述冗余配置能保证邮件发送百分百成功.
*** Mail Commands

- C-c C-c
  Send the message, and bury the mail buffer (=message-send-and-exit=).

- C-c C-s
  Send the message, and leave the mail buffer selected (=message-send=).

- =mail-from-style=
  p- =parens=
  Use both address and full name, as in: 'king@grassland.com (Elvis Parsley)'.

*** Summary
先发出去邮件, 后面的操作便能水到渠成
Emacs Manual的32.Sending-Mail有六个小节.

- [[#32-sending-mail][32) Sending Mail]]
- [[#321-the-format-of-the-mail-buffer][32.1 The Format of the Mail Buffer]]
- [[#322-mail-header-fields][32.2 Mail Header Fields]]
- [[#323-mail-aliases][32.3 Mail Aliases]]
- [[#324-mail-commands][32.4 Mail Commands]]
  - [[#3241-mail-sending][32.4.1 Mail Sending]]
  - [[#3242-mail-header-editing][32.4.2 Mail Header Editing]]
  - [[#3243-citing-mail][32.4.3 Citing Mail]]
  - [[#3244-mail-miscellany][32.4.4 Mail Miscellany]]
- [[#325-mail-signature][32.5 Mail Signature]]
- [[#326-mail-amusements][32.6 Mail Amusements]]

** Rmail
*** Experience movemail
Rmail的后端调用movemail, 因此先手工体验一般movemail
#+BEGIN_SRC bash
sudo apt-get install mailutils
#+END_SRC

命令行中运行
#+BEGIN_SRC bash
movemail -v 'imaps://abst.proc.do:授权码@imap.qq.com:993' ~/RMAIL
#+END_SRC
或者在 =.bashrc= 中alias
#+BEGIN_SRC bash
alias rmail="movemail -v 'imaps://abst.proc.do:授权码@imap.qq.com:993' ~/RMAIL"
#+END_SRC

运行后
#+BEGIN_SRC bash
$ rmail
movemail: number of messages in source mailbox: 1
movemail: number of processed messages: 1
movemail: number of errors: 0 / 0
#+END_SRC

*** View RMAIL File
此时查看Rmail文件

#+BEGIN_SRC bash :results output
cat ~/RMAIL | head -20
#+END_SRC

#+RESULTS:
#+begin_example
From abst.proc.do@qq.com Sun Feb  9 16:15:21 2020
Received: from alpha ([2408:84e1:c9:b898:ec27:f5c0:e2e9:342])
	by newxmesmtplogicsvrsza1.qq.com (NewEsmtp) with SMTP
	id 3D61005A; Sun, 09 Feb 2020 16:15:22 +0800
X-QQ-mid: xmsmtpt1581236122t4scqzp4k
X-QQ-XMAILINFO: N+RU7Cqv682CsQywiWIDqBW+wHZfUBTpX+cVcuEF2CSjI/pLxDbDKwJ/M/iOqN
	 TXJrGlWVB5hoMX68YnRAm3wDeOWUL5f+y87OXcEn0nXTu8k8TZZFHDAPk422wdkrIWIctYc37DM3
	 GXnoiOAE0/pL5B7F4sgPhLYYdIh+uWeQjEbr+HBFZ0JOPlEGX+6IPcq2Pp6m9KHClC+IynnFh2ti
	 kPcv0XT4GgeD+AK1HjAwBwNfZteop0AQIW5gbzdTmDLLoc54wabnTsd12uVuBnWjaLtoH8GPrhol
	 xE+3Zsqw2Sao4QkhQjID46A9xANcnUJstri++//QcGkewMXAFVrIUKo0b0SMhb0O4+tZpoB6Voiq
	 8I64xUygnlIhAq8WQyA/t+skj8lhDUyyhPzpEHeQPgsb1L3YbVuUPAzbBiv/xs96Nm3DF6xP50ms
	 8YA3gRbdvg85SiKWbRy9O1I1d5uGiXbZJv911ozn0fFRdJYaJ1zrCKy8Wk3DShsN+jmWs1pmXeKx
	 W9b7Qxvon5XSwdEQkCVTHqNhRzxfoQA7AAIj9QgJ32V7u+iCqG6qMed+knLKko3JoKiWaJCEsATp
	 wmmcqGz6KQe0h50gf+yG6y/eOYRn6nAnrpXGM=
From: abst.proc.do@qq.com (abst.proc.do)
To: abst.proc.do@qq.com
Subject: =?utf-8?B?5o+Q6ZeuOiDlpoLkvZXorr7nva5tYm94?=
Date: Sun, 09 Feb 2020 16:15:21 +0800
Message-ID: <8736bki3c6.fsf@abst.proc.do>
MIME-Version: 1.0
#+end_example

读到的是普通的文本, 而且decode也有问题, 重置 =rmail-file-coding-system=

#+begin_src emacs-lisp :session sicp :lexical t
(setq rmail-file-coding-system t)
#+end_src

然后在 =~/RMAIL= 中启动 =rmail-mode=,

[[file:./images/rmail-mode.png]]
邮件的基本操作:
- Moving Among Mails
  - n 查看下一封邮件
  Move to the next nondeleted message, skipping any intervening deleted messages (=rmail-next-undeleted-message=).

  - p 查看上一封有家
  Move to the previous nondeleted message (=rmail-previous-undeleted-message=).

- Reply Mails
  - m
  Send a message (=rmail-mail=).

  - c
  Continue editing the already started outgoing message (=rmail-continue=).

  - r
  Send a reply to the current Rmail message (=rmail-reply=).

  - f
  Forward the current message to other users (=rmail-forward=).

  - C-u f
  Resend the current message to other users (=rmail-resend=).

  - M-m
  Try sending a bounced message a second time (=rmail-retry-failure=).

[[file:./images/Reply-Mail.png]]

*** Manually Rmail workflow
总结以上手工Rmail的工作流:
由于配置 =.bashrc=
#+BEGIN_SRC bash
alias rmail="movemail -v 'imaps://abst.proc.do:授权码@imap.qq.com:993' ~/RMAIL"
#+END_SRC

因此可以
1. 从shell中运行rmail, 更新收件箱 =~/RMAIL=,
2. rmail-mode模式下查看 =~/RMAIL=

*** Automatic Rmail
将Rmail workflow的第一步合并进第二步中,
从配置中添加:
#+begin_src emacs-lisp :session email :lexical t
;; Reading Mail
(setq rmail-primary-inbox-list
      '("imaps://abst.proc.do:授权码@imap.qq.com:993")
      )
(setq rmail-movemail-program "/usr/bin/movemail")
#+end_src
load-file后, M-x rmail
运行的message
#+BEGIN_SRC bash
new messages...done (1)
Saving file /home/gaowei/RMAIL...
Wrote /home/gaowei/RMAIL [2 times]
1 new message read
Quit
#+END_SRC
#+ATTR_HTML: :width 500px
[[file:./images/Automatic-Rmail.png]]
*** Summary
Sending Email与Rmail, 可以应用Emacs自如的收发邮件,
但并不能有效的管理邮件.
对邮件进行管理需要引入更加便利的自动化工具gnus

** Gnus: 1.Fundermental Configuration

Gnus的基本配置很简单, 只需要几行代码
新建文件 =~/.gnus= 然后填入以下代码

#+begin_src emacs-lisp :session gnus :lexical t
(setq user-mail-address "abst.proc.do@qq.com"
      user-full-name "abst.proc.do")

(setq gnus-select-method
      '(nnimap "qq.com"
               (nnimap-address "imap.qq.com")
               (nnimap-inbox "INBOX")
               (nnimap-expunge t)
               (nnimap-server-port 993)
               (nnimap-stream ssl)))

(setq send-mail-function 'smtpmail-send-it
      smtpmail-smtp-server "smtp.qq.com"
      smtpmail-smtp-service 465
      smtpmail-stream-type 'ssl
      gnus-ignored-newsgroups "^to\\.\\|^[0-9. ]+\\( \\|$\\)\\|^[\"]\"[#'()]")
#+end_src
并在 =.authinfo= 中加入一行imap的配置,
#+BEGIN_SRC bash
machine imap.qq.com  login abst.proc.do@qq.com password 授权码
machine smtp.qq.com  login abst.proc.do@qq.com password 授权码
#+END_SRC

仅此而已, 便能开工
M-x gnus
调出调出邮件文件夹界面
[[file:./images/gnus-inbox.png]]
提示收到inbox收到2封邮件
也可以 L (gnus-group-list-all-group)查看所有的邮箱文件夹
[[file:./images/gnus-group1.png]]

在 =INBOX= 上按键 =Space= 查看收件箱
#+ATTR_HTML: :width 600px
[[file:./images/gnus-inbox-2.png]]


*退出Gnus*

在Group buffer中按键q退出gnus.
** Gnus: 2.Concepts
Gnus有三个基础概念, Group Buffer, Summary Buffer and Article Buffer
分别对应邮件的 1)分类文件夹(收件箱) 2) 邮件列表 3) 邮件正文

| Gnus           | Mail                |
|----------------+---------------------|
| Group Buffer   | Directoray Category |
| Summary Buffer | Mail list           |
| Article Buffer | Mail Text           |
|----------------+---------------------|

*Group Buffers*
[[file:./images/gnus-group1.png]] [[file:./images/mail-dirs.png]]

*Summary Buffer*

#+ATTR_HTML: :width 400px
[[file:./images/gnus-summary-buffer.png]] [[file:./images/mail-list.png]]

*Article Buffer*
#+ATTR_HTML: :width 300px
[[file:./images/gnus-article-buffer.png]] [[file:./images/mail-text.png]]
** Gnus: 3.Group Buffer
*** Window Layout
M-x gnus默认"use-full-window", 会删掉当前的其他窗口而占据整个屏幕, 因为 =gnus-use-full-window= 默认设置为 =t=, 这会带来诸多不便.
关闭"use-full-window"的模式
#+begin_src emacs-lisp :session sicp :lexical t
(setq gnus-use-full-window nil)
#+end_src

*** Visualize Groups
Group Buffer默认只显示有未读邮件的Group,

查看其他邮件组, 有四种方法

1. 在Group buffer中按键 "j":(gnus-group-jump-to-group), 选择Group后, 并能从Group Buffer中可见
#+ATTR_HTML: :width 400px
[[file:./images/gnus-group-buffer-jump.png]] [[file:./images/gnus-group-buffer-jump-2.png]]

2.Group Buffer中按键 "L":(gnus-group-list-all-groups &optional ARG)
[[file:./images/gnus-group-buffer-list.png]]

3.指定可见的邮件组,
从步骤二中的选择需要的Group, 按键G p, 弹出的对话框中加入一行 =(visible . t)=

[[file:./images/gnus-group-buffer-visiale.png]]

此时重新连接gnus, Group Buffer中按键 Z R, =gnus-summary-reselect-current-group=
重新定义的Group便能显示在初始界面.

4.从Server中查看
Group Buffer中按键 ^ (=gnus-group-enter-server-mode=),
在 "{nnimap:qq.com} (opened)" 上按键Space
#+ATTR_HTML: :width 400px
[[file:./images/gnus-group-buffer-server-1.png]] [[file:./images/gnus-group-buffer-server-2.png]]
也可以一步进入Server Group Buffer: A A (=gnus-group-list-active=)

*** Archive Messages
Gnus的默认配置, 生成 ="sent.%Y-%m"= 格式的 Send-Mail存档, 这与imap的Send-Messages重复, 因此关闭改功能
#+begin_src emacs-lisp :session gnus :lexical t
(setq gnus-message-archive-group nil)
#+end_src

*** New Group
创建新的邮件组
- G m :: Make a new group (=gnus-group-make-group=). Gnus will prompt you for a name, a method and possibly an address.
比如新建Starred Group
G m 之后提示输入Group: Starred,
然后select-method-for-new-group: nnimap:qq.com

Z R 更新 gnus, 然后 L, 便能查看新建的starred Group
设置为可视,
G p 之后, 添加一行
=(visible . t)=

*** Delete and Rename Group
- G <DEL> :: gnus-group-delete-group
删除当前的邮件组
- b :: Find bogus groups and delete them (=gnus-group-check-bogus-groups=).
删除bogus邮件组

- G r :: Rename the current group to something else (=gnus-group-rename-group=). This is valid only on some groups---mail groups mostly. This command might very well be quite slow on some back ends.

*** Mark Groups
- c ::  Mark all unticked articles in this group as read (=gnus-group-catchup-current=). =gnus-group-catchup-group-hook= is called when catching up a group from the group buffer.
- C :: Mark all articles in this group, even the ticked ones, as read (=gnus-group-catchup-current-all=).
表组Group内所有邮件为已读

- # ::
- M m :: Set the mark on the current group (=gnus-group-mark-group=).
- M-# ::
- M u :: Remove the mark from the current group (=gnus-group-unmark-group=).
- M U :: Remove the mark from all groups (=gnus-group-unmark-all-groups=).
- M w :: Mark all groups between point and mark (=gnus-group-mark-region=).
- M b :: Mark all groups in the buffer (=gnus-group-mark-buffer=).
- M r :: Mark all groups that match some regular expression (=gnus-group-mark-regexp=).
*** Sorting Groups
常用的排序方法:
- G S a :: Sort the group buffer alphabetically by group name (=gnus-group-sort-groups-by-alphabet=).
- G S m :: Sort the group buffer alphabetically by back end name
  (=gnus-group-sort-groups-by-method=).
- G S n :: Sort the group buffer alphabetically by real (unprefixed) group name (=gnus-group-sort-groups-by-real-name=).
*** Group Timestamp
Trace最近一次打开group的时间戳.(add-hook 'gnus-select-group-hook 'gnus-group-set-timestamp
It can be convenient to let Gnus keep track of when you last read a group. To set the ball rolling, you should add =gnus-group-set-timestamp= to =gnus-select-group-hook=:
添加配置:
#+begin_src emacs-lisp :session gnus :lexical t
(add-hook 'gnus-select-group-hook 'gnus-group-set-timestamp)

(setq gnus-group-line-format
      "%M%S%p%P%5y: %(%-40,40g%) %udn")
         (defun gnus-user-format-function-d (headers)
           (let ((time (gnus-group-timestamp gnus-tmp-group)))
             (if time
                 (format-time-string "%b %d  %H:%M" time)
               "")))
#+end_src

*** Group Highlighting
Gnus Manual中推荐的highlight配色配置,
#+begin_src emacs-lisp :session gnus :lexical t
(cond (window-system
       (setq custom-background-mode 'light)
       (defface my-group-face-1
         '((t (:foreground "Red" :bold t))) "First group face")
       (defface (message "")y-group-face-2
         '((t (:foreground "DarkSeaGreen4" :bold t)))
         "Second group face")
       (defface my-group-face-3
         '((t (:foreground "Green4" :bold t))) "Third group face")
       (defface my-group-face-4
         '((t (:foreground "SteelBlue" :bold t))) "Fourth group face")
       (defface my-group-face-5
         '((t (:foreground "Blue" :bold t))) "Fifth group face")))

(setq gnus-group-highlight
      '(((> unread 200) . my-group-face-1)
        ((and (< level 3) (zerop unread)) . my-group-face-2)
        ((< level 3) . my-group-face-3)
        ((zerop unread) . my-group-face-4)
        (t . my-group-face-5)))
#+end_src
** Gnus: 4.Summary Buffer
*** Display all
Summary Buffer是Email list,
"INBOX"默认只读取"未读"邮件, 没有未读邮件则为空, 此默认设置并不实用.
从Group Buffer中的"inbox",操作 G p, 添加一行 =(display . all)=
#+begin_src emacs-lisp :session gnus :lexical t
((modseq)
 (uidvalidity .
              #("1579733041" 0 10
                (ws-butler-chg chg)))
 (active 1 . 95)
 (timestamp 24131 49229)
 (display . all) ;; display all emails
 (visible . t)
 (permanent-flags %* %Answered %Flagged %Deleted %Draft %Seen))
#+end_src
*** Delete Mails
Gnus删除邮件需要格外注意,
首先设置,
#+begin_src emacs-lisp :session gnus :lexical t
;; Delele mail
(setq nnmail-expiry-wait 'never)
(setq nnmail-expiry-target "Deleted Messages")
#+end_src

=nnmail-expiry-wait= 设置为never, 避免gnus自动删除邮件

删除邮件的动作, 操作移动邮件来完成.
Summary-Buffer中操作 B m, 选定待删除的邮件移动到"Deleted Messages"
- B m :: Move the article from one mail group to another (=gnus-summary-move-article=). Marks will be preserved if =gnus-preserve-marks= is =non-nil= (which is the default).

#+ATTR_HTML: :width 600px
[[file:./images/gnus-summary-buffer-delete.png]]

*** Search Mails
从Summary Buffer中查找邮件.
M-s
    Search through all subsequent (raw) articles for a regexp (gnus-summary-search-article-forward).
M-r
    Search through all previous (raw) articles for a regexp (gnus-summary-search-article-backward).
M-&
    Perform any operation on all articles that have been marked with the process mark (gnus-summary-universal-argument).

不错, 测试的结果是"可以用"

也可以从"Group Buffer"中直接搜索

G G :: =nnir= is a Gnus interface to a number of tools for searching through mail and news repositories. Different backends (like =nnimap= and =nntp=) work with different tools (called engines in =nnir= lingo), but all use the same basic search interface.


*** Frequent Commands
*回复邮件*
- S r
  r ::  Mail a reply to the author of the current article (=gnus-summary-reply=).
- S R
  R ::  Mail a reply to the author of the current article and include the original message (=gnus-summary-reply-with-original=). This command uses  the process/prefix convention
- S w :: Mail a wide reply to the author of the current article (=gnus-summary-wide-reply=). A wide reply is a reply that goes out to all people listed in the =To=, =From= (or =Reply-to=) and =Cc= headers. If =Mail-Followup-To= is present, that's used instead.
- S W :: Mail a wide reply to the current article and include the original message (=gnus-summary-wide-reply-with-original=). This command uses the process/prefix convention, but only uses the headers from the first article to determine the recipients.
- S f or  f ::  Post a followup to the current article (=gnus-summary-followup=).
- S F or  F :: Post a followup to the current article and include the original message (=gnus-summary-followup-with-original=). This command uses the process/prefix convention.
# 短评: 对邮件, follow-up与replay没有区别.

*写邮件与转发邮件*
- S p or a ::  Prepare for posting an article (=gnus-summary-post-news=). By default, post to the current group. If given a prefix, disable that. If the prefix is 1, prompt for another group instead.
# 短评: 直接用m就好了.
- S m or  m ::  Prepare a mail (=gnus-summary-mail-other-window=). By default, use the posting style of the current group. If given a prefix, disable that. If the prefix is 1, prompt for a group name to find the posting style.
*取消发送*
- S c :: Canceling Article
  Find the article you wish to cancel (you can only cancel your own articles, so don't try any funny stuff). Then press C or S c (=gnus-summary-cancel-article=). Your article will be canceled---machines all over the world will be deleting your article. This command uses the process/prefix convention.
*延迟发送*
- C-c C-j  :: Delayed Articles

 Normally, to send a message you use the C-c C-c command from Message mode. To delay a message, use C-c C-j (=gnus-delay-article=) instead.

*Mark Articles*
- M c or M-u :: Clear all readedness-marks from the current article (=gnus-summary-clear-mark-forward=). In other words, mark the article as unread.
- M t or  ! :: Tick the current article (=gnus-summary-tick-article-forward=).

- M C ::  Mark all unread articles as read (=gnus-summary-catchup=).
# 得到: 这是从article中操作
- M C-c :: Mark all articles in the group as read---even the ticked and dormant articles (=gnus-summary-catchup-all=).
# 短评: 这两个在summary buffer中的操作很实用.
# 标记与取消的命令同样重要．

*Process Mark*
Process marks are displayed as =#= in the summary buffer, and are used for marking articles in such a way that other commands will process these articles.
- M P p
  # ::
- M P u or M-# :: Remove the process mark, if any, from the current article (=gnus-summary-unmark-as-processable=).
# 短评, 这些需要用的时候再看文档.
- M P U :: Remove the process mark from all articles (=gnus-summary-unmark-all-processable=).

*Thread Commands*
- T k
  C-M-k :: Mark all articles in the current (sub-)thread as read (=gnus-summary-kill-thread=). If the prefix argument is positive, remove all marks instead. If the prefix argument is negative, tick articles instead.

*Asynchronous Fetch*
;;3.11 Asynchronous Article Fetching
(setq gnus-asynchronous t)
;;pre-fetch only unread articles shorter than 100 lines, you could say something like:
(defun my-async-short-unread-p (data)
  "Return non-nil for short, unread articles."
  (and (gnus-data-unread-p data)
       (< (mail-header-lines (gnus-data-header data))
          100)))
(setq gnus-async-prefetch-article-p 'my-async-short-unread-p)

*3.13 Persistent Articles*

- * :: Make the current article persistent (=gnus-cache-enter-article=).
- M-* :: Remove the current article from the persistent articles (=gnus-cache-remove-article=). This will normally delete the article.

#+BEGIN_SRC elisp
(setq gnus-use-cache 'passive)
#+END_SRC

*Article Treatement*
highlight的部分值得一看, 但是在第三部分article中.

*Summary Sorting*

 You can have the summary buffer sorted in various ways, even though I can't really see why you'd want that.

- C-c C-s C-n :: Sort by article number (=gnus-summary-sort-by-number=).
- C-c C-s C-m C-n :: Sort by most recent article number (=gnus-summary-sort-by-most-recent-number=).
- C-c C-s C-a :: Sort by author (=gnus-summary-sort-by-author=).
- C-c C-s C-t :: Sort by recipient (=gnus-summary-sort-by-recipient=).
- C-c C-s C-s :: Sort by subject (=gnus-summary-sort-by-subject=).
- C-c C-s C-d :: Sort by date (=gnus-summary-sort-by-date=).
- C-c C-s C-m C-d :: Sort by most recent date (=gnus-summary-sort-by-most-recent-date=).
- C-c C-s C-l :: Sort by lines (=gnus-summary-sort-by-lines=).
- C-c C-s C-c :: Sort by article length (=gnus-summary-sort-by-chars=).
- C-c C-s C-m C-m :: Sort by article “readedness” marks (=gnus-summary-sort-by-marks=).
- C-c C-s C-i :: Sort by score (=gnus-summary-sort-by-score=).
- C-c C-s C-r :: Randomize (=gnus-summary-sort-by-random=).
- C-c C-s C-o :: Sort using the default sorting method (=gnus-summary-sort-by-original=).

*3.23 Finding the Parent*

- ^ :: If you'd like to read the parent of the current article, and it is not displayed in the summary buffer, you might still be able to.
** Gnus: 5.Article Buffer
"Article Buffer"是邮件的正文内容．

*Hiding Headers*
#+begin_src emacs-lisp :session gnus :lexical t
(setq gnus-visible-headers "^From:|^Subject:")
(setq gnus-ignored-headers "^References:|^Xref:")
(setq gnus-sorted-header-list '("^From:" "^Subject:"))
#+end_src

*Block Ads*
#+begin_src emacs-lisp :session gnus :lexical t
(setq gnus-blocked-images "ads")
#+end_src
